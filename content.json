{"meta":{"title":"Yuchuan's Blog","subtitle":null,"description":"","author":"Yuchuan","url":"https://yuchuan93.github.io/blog.github.io","root":"/blog.github.io/"},"pages":[{"title":"archives","date":"2020-06-12T15:02:30.000Z","updated":"2020-06-12T15:06:49.500Z","comments":true,"path":"archives/index.html","permalink":"https://yuchuan93.github.io/blog.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-06-12T15:19:39.000Z","updated":"2020-06-12T15:20:09.048Z","comments":true,"path":"categories/index.html","permalink":"https://yuchuan93.github.io/blog.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-10T13:57:48.000Z","updated":"2020-07-10T13:58:26.366Z","comments":true,"path":"tags/index.html","permalink":"https://yuchuan93.github.io/blog.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"实现一个可以溶解的平面投影阴影","slug":"ProjectorShadowDissolve","date":"2020-07-05T13:45:01.000Z","updated":"2020-07-10T13:53:12.241Z","comments":true,"path":"2020/07/05/ProjectorShadowDissolve/","link":"","permalink":"https://yuchuan93.github.io/blog.github.io/2020/07/05/ProjectorShadowDissolve/","excerpt":"​ 最近项目项目上用到了平面投影阴影，原理是用一个单独的pass将模型顶点投影到一个平面上，这种方式有着不错的效率，但是也只能用在比较平的地面上，我们的项目刚好适用，而且还能跟随模型实现溶解的效果，一举两得。 先来看看怎么实现阴影原理​ 实现投影阴影其实就是计算每一个顶点沿着光线方向与投影平面的交点坐标，然后将该点以黑色渲染出来，想象一下将这个模型沿着光线方向一巴掌拍扁在平面上，就是这个意思。我们可以用相似三角形原理来求它，如下图：","text":"​ 最近项目项目上用到了平面投影阴影，原理是用一个单独的pass将模型顶点投影到一个平面上，这种方式有着不错的效率，但是也只能用在比较平的地面上，我们的项目刚好适用，而且还能跟随模型实现溶解的效果，一举两得。 先来看看怎么实现阴影原理​ 实现投影阴影其实就是计算每一个顶点沿着光线方向与投影平面的交点坐标，然后将该点以黑色渲染出来，想象一下将这个模型沿着光线方向一巴掌拍扁在平面上，就是这个意思。我们可以用相似三角形原理来求它，如下图： ​ ​ 现在问题转化为：已知B点和单位向量L（光照方向），求C点坐标。 ​ 由相似三角形定理，即对应边的比例相等，则有： -\\frac{Ly}{By}=\\frac{Lx}{Cx-Bx}​ 我们可以传入一个自定义的高度h，表示需要投影的平面高度： -\\frac{Ly}{By-h}=\\frac{Lx}{Cx-Bx}​ 那么就有： Cx=Bx-\\frac{Lx(By-h)}{Ly} Cy=h​ 现在我们是在二维平面下进行的推导，放到三维也是一样的。 实现​ 上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Pass &#123; Blend SrcAlpha OneMinusSrcAlpha ZWrite off CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct appdata &#123; float4 vertex : POSITION; &#125;; struct v2f &#123; float4 vertex : SV_POSITION; float4 color : COLOR; &#125;; uniform float _PlaneHeight; uniform fixed3 _VirtualLightDir; uniform fixed3 _ShadowColor; float3 ShadowProjectPos(float4 vertPos) &#123; float3 shadowPos; &#x2F;&#x2F;得到顶点的世界空间坐标 float3 worldPos &#x3D; mul(unity_ObjectToWorld, vertPos).xyz; &#x2F;&#x2F;灯光方向 float3 lightDir &#x3D; normalize(_VirtualLightDir.xyz); &#x2F;&#x2F;阴影的世界空间坐标（低于地面的部分不做改变） shadowPos.y &#x3D; min(worldPos.y, _PlaneHeight); shadowPos.xz &#x3D; worldPos.xz - lightDir.xz * max(0, worldPos.y - _PlaneHeight) &#x2F; lightDir.y; return shadowPos; &#125; v2f vert (appdata v) &#123; v2f o; &#x2F;&#x2F;得到阴影的世界空间坐标 float3 shadowPos &#x3D; ShadowProjectPos(v.vertex); &#x2F;&#x2F;转换到裁切空间 o.vertex &#x3D; UnityWorldToClipPos(shadowPos); return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; return fixed4(_ShadowColor, 1); &#125; ENDCG &#125; ​ 同时，我们需要从外部传入需要的参数，我这里直接在场景中创建一个空物体，挂上下面这个脚本，设置几个shader全局变量，也方便在场景中预览效果。 VirtualLight.cs12345678910111213141516171819using UnityEngine;[ExecuteInEditMode]public class VirtualLight : MonoBehaviour&#123; private int colorPropID = Shader.PropertyToID(\"_ShadowColor\"); private int lightDir = Shader.PropertyToID(\"_VirtualLightDir\"); private int heightPropID = Shader.PropertyToID(\"_PlaneHeight\"); public Color shadowColor; public float height; void Update() &#123; Shader.SetGlobalColor(colorPropID, shadowColor); Shader.SetGlobalFloat(heightPropID, height); Shader.SetGlobalVector(lightDir, transform.forward); &#125;&#125; ​ 到此，阴影效果就实现了，具体表现如下： ​ 但是遇到了问题，当调节阴影的透明度时，效果就不正常了，如下图。这是因为阴影是平面的，但是我们计算的顶点却不是，这会造成很多顶点会重合的覆盖在平面上，造成颜色的叠加，解决办法就是用模板测试，丢弃那些会重合的像素。 ​ 修改后的代码如下： 12345678910111213141516171819202122232425Pass &#123; Blend SrcAlpha OneMinusSrcAlpha ZWrite off Cull Back Stencil &#123; &#x2F;&#x2F; 参考值，表示每个像素用这个值来进行测试 Ref 0 &#x2F;&#x2F; 比较方式，如果模板值等于参考值则通过测试，模板值初始为0 Comp equal &#x2F;&#x2F; 通过后模板值加1，这样后面的模板测试则不会通过了，保证一个像素只会填充一次 Pass incrWrap &#x2F;&#x2F; 模板测试和深度测试失败，保持原来的模板值 Fail keep &#x2F;&#x2F; 模板测试成功和深度测试失败，保持原来的模板值 ZFail keep &#125; CGPROGRAM -------- ENDCG &#125; 接下来就是溶解效果了原理​ 溶解就是利用透明度测试来实现，我们可以用一张灰度图来进行采样，然后再调节一个阈值，当采样到的值低于这个阈值时则抛弃这个像素。需要知道的是，我们不仅要模型本身要溶解，阴影也要溶解，所以两个pass都要进行同样的操作，这样会增加一次采样的消耗，不过不碍事，本次用到的灰度图如下： 实现​ 增加了溶解的shader完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148Shader &quot;Yuchuan&#x2F;PlaneProjectorShadow&quot;&#123; Properties &#123; _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125; _DissolveMap(&quot;DissolveMap&quot;, 2D) &#x3D; &quot;white&quot;&#123;&#125; _DissolveThreshold(&quot;DissolveThreshold&quot;, Range(0,1)) &#x3D; 0 &#125; SubShader &#123; Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &#125; LOD 100 Pass &#123; Blend SrcAlpha OneMinusSrcAlpha ZWrite off Cull Back Stencil &#123; &#x2F;&#x2F; 参考值，表示每个像素用这个值来进行测试 Ref 0 &#x2F;&#x2F; 比较方式，如果模板值等于参考值则通过测试，模板值初始为0 Comp equal &#x2F;&#x2F; 通过后模板值加1，这样后面的模板测试则不会通过了，保证一个像素只会填充一次 Pass incrWrap &#x2F;&#x2F; 模板测试和深度测试失败，保持原来的模板值 Fail keep &#x2F;&#x2F; 模板测试成功和深度测试失败，保持原来的模板值 ZFail keep &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; struct v2f &#123; float4 vertex : SV_POSITION; float4 color : COLOR; float2 uv : TEXCOORD0; &#125;; uniform float _PlaneHeight; uniform fixed3 _VirtualLightDir; uniform fixed4 _ShadowColor; sampler2D _DissolveMap; float _DissolveThreshold; float3 ShadowProjectPos(float4 vertPos) &#123; float3 shadowPos; &#x2F;&#x2F;得到顶点的世界空间坐标 float3 worldPos &#x3D; mul(unity_ObjectToWorld, vertPos).xyz; &#x2F;&#x2F;灯光方向 float3 lightDir &#x3D; normalize(_VirtualLightDir.xyz); &#x2F;&#x2F;阴影的世界空间坐标（低于地面的部分不做改变） shadowPos.y &#x3D; min(worldPos.y, _PlaneHeight); shadowPos.xz &#x3D; worldPos.xz - lightDir.xz * max(0, worldPos.y - _PlaneHeight) &#x2F; lightDir.y; return shadowPos; &#125; v2f vert (appdata v) &#123; v2f o; &#x2F;&#x2F;得到阴影的世界空间坐标 float3 shadowPos &#x3D; ShadowProjectPos(v.vertex); &#x2F;&#x2F;转换到裁切空间 o.vertex &#x3D; UnityWorldToClipPos(shadowPos); o.uv &#x3D; v.uv; return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; fixed4 mask &#x3D; tex2D(_DissolveMap, i.uv); if (mask.r &lt; _DissolveThreshold) discard; return _ShadowColor; &#125; ENDCG &#125; Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; struct v2f &#123; float2 uv : TEXCOORD0; float3 worldNormal : TEXCOORD1; float4 vertex : SV_POSITION; &#125;; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _DissolveMap; float _DissolveThreshold; v2f vert (appdata v) &#123; v2f o; o.vertex &#x3D; UnityObjectToClipPos(v.vertex); o.worldNormal &#x3D; UnityObjectToWorldNormal(v.vertex); o.uv &#x3D; TRANSFORM_TEX(v.uv, _MainTex); return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; fixed4 col &#x3D; tex2D(_MainTex, i.uv); fixed4 mask &#x3D; tex2D(_DissolveMap, i.uv); if (mask.r &lt; _DissolveThreshold) discard; return col; &#125; ENDCG &#125; &#125;&#125;","categories":[],"tags":[{"name":"shader","slug":"shader","permalink":"https://yuchuan93.github.io/blog.github.io/tags/shader/"}]},{"title":"开始吧","slug":"MyFirstBlog","date":"2020-06-12T15:22:20.000Z","updated":"2020-07-07T17:09:10.192Z","comments":true,"path":"2020/06/12/MyFirstBlog/","link":"","permalink":"https://yuchuan93.github.io/blog.github.io/2020/06/12/MyFirstBlog/","excerpt":"为什么要建博客​ 花了几天时间，终于有了一个属于自己的博客，虽然我是一个工作几年的程序员，但搭建这个博客也还是耗费了些许精力，真是惭愧。我为什么想要弄一个自己的博客呢？其实这个想法很早就有了，但是一直因为各种原因（我不会说是因为拖延症）一直没有着手。直到最近，我突然发现工作了几年下来，总是感觉缺了点什么，没有自己能看得见的积累，自身的成长也很慢，我虽然一直对未来没有很迷茫，但目前多少有点不知所措，所以这个博客也算是很有必要了。","text":"为什么要建博客​ 花了几天时间，终于有了一个属于自己的博客，虽然我是一个工作几年的程序员，但搭建这个博客也还是耗费了些许精力，真是惭愧。我为什么想要弄一个自己的博客呢？其实这个想法很早就有了，但是一直因为各种原因（我不会说是因为拖延症）一直没有着手。直到最近，我突然发现工作了几年下来，总是感觉缺了点什么，没有自己能看得见的积累，自身的成长也很慢，我虽然一直对未来没有很迷茫，但目前多少有点不知所措，所以这个博客也算是很有必要了。 这个博客要写些什么​ 首先会写的肯定是我的主业相关，也就是Unity游戏开发的相关内容，这可能会包括引擎相关技术、功能实现、渲染等；然后就是在工作中遇到的技术问题，这个博客一大用处就是在你解决问题后能将它记录下来，在记录的过程中也便于自己加深理解；除了这些技术相关的博文，我肯定还会有其他想要记录的东西，只是现在我还没有纳入或者说还没有发现。 我期望这个博客能带来什么成长​ 希望我能通过这个博客改变我现有的一些工作方式，慢慢学习去记录，通过记录来提高对陌生知识的吸收效率，让自己的成长更快。 分享​ 把遇到的问题或者一些自己感觉到很酷的东西分享出来，不再自己一个人埋头苦干，如果有人能看到，然后能跟你交流，这也是一种快乐吧！","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"shader","slug":"shader","permalink":"https://yuchuan93.github.io/blog.github.io/tags/shader/"}]}