<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实现一个可以溶解的平面投影阴影</title>
      <link href="/blog.github.io/2020/07/05/ProjectorShadowDissolve/"/>
      <url>/blog.github.io/2020/07/05/ProjectorShadowDissolve/</url>
      
        <content type="html"><![CDATA[<p>​    最近项目项目上用到了平面投影阴影，原理是用一个单独的pass将模型顶点投影到一个平面上，这种方式有着不错的效率，但是也只能用在比较平的地面上，我们的项目刚好适用，而且还能跟随模型实现溶解的效果，一举两得。</p><h3 id="先来看看怎么实现阴影"><a href="#先来看看怎么实现阴影" class="headerlink" title="先来看看怎么实现阴影"></a>先来看看怎么实现阴影</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>​    实现投影阴影其实就是计算每一个顶点沿着光线方向与投影平面的交点坐标，然后将该点以黑色渲染出来，想象一下将这个模型沿着光线方向一巴掌拍扁在平面上，就是这个意思。我们可以用相似三角形原理来求它，如下图：</p><a id="more"></a><p>​    <img src=".\planerProjectorShadow.png" alt=""></p><p>​    现在问题转化为：已知B点和单位向量L（光照方向），求C点坐标。</p><p>​    由相似三角形定理，即对应边的比例相等，则有：</p><script type="math/tex; mode=display">-\frac{Ly}{By}=\frac{Lx}{Cx-Bx}</script><p>​    我们可以传入一个自定义的高度h，表示需要投影的平面高度：</p><script type="math/tex; mode=display">-\frac{Ly}{By-h}=\frac{Lx}{Cx-Bx}</script><p>​    那么就有：</p><script type="math/tex; mode=display">Cx=Bx-\frac{Lx(By-h)}{Ly}</script><script type="math/tex; mode=display">Cy=h</script><p>​    现在我们是在二维平面下进行的推导，放到三维也是一样的。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>​    上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ZWrite off</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">    </span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float4 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            uniform float _PlaneHeight;</span><br><span class="line">            uniform fixed3 _VirtualLightDir;</span><br><span class="line">            uniform fixed3 _ShadowColor;</span><br><span class="line">    </span><br><span class="line">            float3 ShadowProjectPos(float4 vertPos)</span><br><span class="line">            &#123;</span><br><span class="line">                float3 shadowPos;</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;得到顶点的世界空间坐标</span><br><span class="line">                float3 worldPos &#x3D; mul(unity_ObjectToWorld, vertPos).xyz;</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;灯光方向</span><br><span class="line">                float3 lightDir &#x3D; normalize(_VirtualLightDir.xyz);</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;阴影的世界空间坐标（低于地面的部分不做改变）</span><br><span class="line">                shadowPos.y &#x3D; min(worldPos.y, _PlaneHeight);</span><br><span class="line">                shadowPos.xz &#x3D; worldPos.xz - lightDir.xz * max(0, worldPos.y - _PlaneHeight) &#x2F; lightDir.y; </span><br><span class="line">    </span><br><span class="line">                return shadowPos;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;得到阴影的世界空间坐标</span><br><span class="line">                float3 shadowPos &#x3D; ShadowProjectPos(v.vertex);</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;转换到裁切空间</span><br><span class="line">                o.vertex &#x3D; UnityWorldToClipPos(shadowPos);</span><br><span class="line">    </span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                return fixed4(_ShadowColor, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​    同时，我们需要从外部传入需要的参数，我这里直接在场景中创建一个空物体，挂上下面这个脚本，设置几个shader全局变量，也方便在场景中预览效果。</p><figure class="highlight c"><figcaption><span>VirtualLight.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode]</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualLight</span> :</span> MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> colorPropID = Shader.PropertyToID(<span class="string">"_ShadowColor"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lightDir = Shader.PropertyToID(<span class="string">"_VirtualLightDir"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heightPropID = Shader.PropertyToID(<span class="string">"_PlaneHeight"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color shadowColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> <span class="built_in">height</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Shader.SetGlobalColor(colorPropID, shadowColor);</span><br><span class="line">        Shader.SetGlobalFloat(heightPropID, <span class="built_in">height</span>);</span><br><span class="line">        Shader.SetGlobalVector(lightDir, transform.forward);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    到此，阴影效果就实现了，具体表现如下：</p><iframe src="final.gif" width="800" height="800" frameborder="0" loading="lazy" allowfullscreen></iframe><p>​    但是遇到了问题，当调节阴影的透明度时，效果就不正常了，如下图。这是因为阴影是平面的，但是我们计算的顶点却不是，这会造成很多顶点会重合的覆盖在平面上，造成颜色的叠加，解决办法就是用模板测试，丢弃那些会重合的像素。</p><p><img src=".\shadowerror.png" alt=""></p><p>​    修改后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ZWrite off</span><br><span class="line">            Cull Back</span><br><span class="line"></span><br><span class="line">            Stencil</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 参考值，表示每个像素用这个值来进行测试</span><br><span class="line">                Ref 0</span><br><span class="line">                &#x2F;&#x2F; 比较方式，如果模板值等于参考值则通过测试，模板值初始为0</span><br><span class="line">                Comp equal</span><br><span class="line">                &#x2F;&#x2F; 通过后模板值加1，这样后面的模板测试则不会通过了，保证一个像素只会填充一次</span><br><span class="line">                Pass incrWrap</span><br><span class="line">                &#x2F;&#x2F; 模板测试和深度测试失败，保持原来的模板值</span><br><span class="line">                Fail keep</span><br><span class="line">                &#x2F;&#x2F; 模板测试成功和深度测试失败，保持原来的模板值</span><br><span class="line">                ZFail keep</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            --------</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="接下来就是溶解效果了"><a href="#接下来就是溶解效果了" class="headerlink" title="接下来就是溶解效果了"></a>接下来就是溶解效果了</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>​    溶解就是利用透明度测试来实现，我们可以用一张灰度图来进行采样，然后再调节一个阈值，当采样到的值低于这个阈值时则抛弃这个像素。需要知道的是，我们不仅要模型本身要溶解，阴影也要溶解，所以两个pass都要进行同样的操作，这样会增加一次采样的消耗，不过不碍事，本次用到的灰度图如下：</p><p><img src=".\DissolveMaskSampleImage.png" alt=""></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>​    增加了溶解的shader完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shader &quot;Yuchuan&#x2F;PlaneProjectorShadow&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;</span><br><span class="line">        _DissolveMap(&quot;DissolveMap&quot;, 2D) &#x3D; &quot;white&quot;&#123;&#125;</span><br><span class="line">        _DissolveThreshold(&quot;DissolveThreshold&quot;, Range(0,1)) &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD 100</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ZWrite off</span><br><span class="line">            Cull Back</span><br><span class="line">    </span><br><span class="line">            Stencil</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 参考值，表示每个像素用这个值来进行测试</span><br><span class="line">                Ref 0</span><br><span class="line">                &#x2F;&#x2F; 比较方式，如果模板值等于参考值则通过测试，模板值初始为0</span><br><span class="line">                Comp equal</span><br><span class="line">                &#x2F;&#x2F; 通过后模板值加1，这样后面的模板测试则不会通过了，保证一个像素只会填充一次</span><br><span class="line">                Pass incrWrap</span><br><span class="line">                &#x2F;&#x2F; 模板测试和深度测试失败，保持原来的模板值</span><br><span class="line">                Fail keep</span><br><span class="line">                &#x2F;&#x2F; 模板测试成功和深度测试失败，保持原来的模板值</span><br><span class="line">                ZFail keep</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">    </span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float4 color : COLOR;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            uniform float _PlaneHeight;</span><br><span class="line">            uniform fixed3 _VirtualLightDir;</span><br><span class="line">            uniform fixed4 _ShadowColor;</span><br><span class="line">            sampler2D  _DissolveMap;</span><br><span class="line">            float _DissolveThreshold;</span><br><span class="line">    </span><br><span class="line">            float3 ShadowProjectPos(float4 vertPos)</span><br><span class="line">            &#123;</span><br><span class="line">                float3 shadowPos;</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;得到顶点的世界空间坐标</span><br><span class="line">                float3 worldPos &#x3D; mul(unity_ObjectToWorld, vertPos).xyz;</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;灯光方向</span><br><span class="line">                float3 lightDir &#x3D; normalize(_VirtualLightDir.xyz);</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;阴影的世界空间坐标（低于地面的部分不做改变）</span><br><span class="line">                shadowPos.y &#x3D; min(worldPos.y, _PlaneHeight);</span><br><span class="line">                shadowPos.xz &#x3D; worldPos.xz - lightDir.xz * max(0, worldPos.y - _PlaneHeight) &#x2F; lightDir.y; </span><br><span class="line">    </span><br><span class="line">                return shadowPos;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;得到阴影的世界空间坐标</span><br><span class="line">                float3 shadowPos &#x3D; ShadowProjectPos(v.vertex);</span><br><span class="line">    </span><br><span class="line">                &#x2F;&#x2F;转换到裁切空间</span><br><span class="line">                o.vertex &#x3D; UnityWorldToClipPos(shadowPos);</span><br><span class="line">    </span><br><span class="line">                o.uv &#x3D; v.uv;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 mask &#x3D; tex2D(_DissolveMap, i.uv);</span><br><span class="line">                if (mask.r &lt; _DissolveThreshold)</span><br><span class="line">                discard;</span><br><span class="line">                return _ShadowColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">    </span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line">    </span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 worldNormal : TEXCOORD1;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D  _DissolveMap;</span><br><span class="line">            float _DissolveThreshold;</span><br><span class="line">    </span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex &#x3D; UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal &#x3D; UnityObjectToWorldNormal(v.vertex);</span><br><span class="line">                o.uv &#x3D; TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 col &#x3D; tex2D(_MainTex, i.uv);</span><br><span class="line">                fixed4 mask &#x3D; tex2D(_DissolveMap, i.uv);</span><br><span class="line">                if (mask.r &lt; _DissolveThreshold)</span><br><span class="line">                discard;</span><br><span class="line">    </span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始吧</title>
      <link href="/blog.github.io/2020/06/12/MyFirstBlog/"/>
      <url>/blog.github.io/2020/06/12/MyFirstBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要建博客"><a href="#为什么要建博客" class="headerlink" title="为什么要建博客"></a>为什么要建博客</h2><p>​    花了几天时间，终于有了一个属于自己的博客，虽然我是一个工作几年的程序员，但搭建这个博客也还是耗费了些许精力，真是惭愧。我为什么想要弄一个自己的博客呢？其实这个想法很早就有了，但是一直因为各种原因（我不会说是因为拖延症）一直没有着手。直到最近，我突然发现工作了几年下来，总是感觉缺了点什么，没有自己能看得见的积累，自身的成长也很慢，我虽然一直对未来没有很迷茫，但目前多少有点不知所措，所以这个博客也算是很有必要了。</p><a id="more"></a><h2 id="这个博客要写些什么"><a href="#这个博客要写些什么" class="headerlink" title="这个博客要写些什么"></a>这个博客要写些什么</h2><p>​    首先会写的肯定是我的主业相关，也就是Unity游戏开发的相关内容，这可能会包括引擎相关技术、功能实现、渲染等；然后就是在工作中遇到的技术问题，这个博客一大用处就是在你解决问题后能将它记录下来，在记录的过程中也便于自己加深理解；除了这些技术相关的博文，我肯定还会有其他想要记录的东西，只是现在我还没有纳入或者说还没有发现。</p><h2 id="我期望这个博客能带来什么"><a href="#我期望这个博客能带来什么" class="headerlink" title="我期望这个博客能带来什么"></a>我期望这个博客能带来什么</h2><h3 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h3><p>​    希望我能通过这个博客改变我现有的一些工作方式，慢慢学习去记录，通过记录来提高对陌生知识的吸收效率，让自己的成长更快。</p><h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>​    把遇到的问题或者一些自己感觉到很酷的东西分享出来，不再自己一个人埋头苦干，如果有人能看到，然后能跟你交流，这也是一种快乐吧！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
